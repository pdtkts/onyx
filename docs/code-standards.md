# Code Standards

## General Principles

- **YAGNI** -- Don't build it until you need it
- **KISS** -- Simplest solution that works
- **DRY** -- Extract shared logic, avoid copy-paste
- **Immutability** -- Create new objects, don't mutate

## File Organization

- Keep files under 200 lines where possible (800 max)
- Use kebab-case for filenames: `user-auth-handler.py`, `chat-message-list.tsx`
- Organize by feature/domain, not by type
- One concept per module, high cohesion, low coupling
- **Do NOT import from `ee/` directories** -- this fork uses MIT-only code. Custom features go in `backend/features/` (backend) and `web/src/app/features/` (frontend)

## Python (Backend)

### Style & Formatting

| Rule | Convention |
|------|-----------|
| Formatter | Black (via pre-commit or manual) |
| Linter | Ruff |
| Type checking | mypy (partial) |
| Import order | stdlib > third-party > local (isort) |
| Naming | `snake_case` for functions/variables, `PascalCase` for classes |
| Constants | `UPPER_SNAKE_CASE` |
| Max line length | 88 (Black default) |

### Project Structure Conventions

```python
# FastAPI router pattern
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from onyx.db.engine import get_session

router = APIRouter(prefix="/api/endpoint", tags=["endpoint"])

@router.get("/items")
def list_items(
    db_session: Session = Depends(get_session),
    user: User | None = Depends(current_user),
) -> list[ItemResponse]:
    ...
```

### Pydantic Models

```python
from pydantic import BaseModel

class ItemCreate(BaseModel):
    name: str
    description: str | None = None

class ItemResponse(BaseModel):
    id: int
    name: str
    description: str | None

    class Config:
        from_attributes = True
```

### Database (SQLAlchemy)

```python
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from onyx.db.models import Base

class Item(Base):
    __tablename__ = "item"

    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    owner_id = Column(Integer, ForeignKey("user.id"))
    owner = relationship("User", back_populates="items")
```

### Error Handling

```python
from onyx.utils.logger import setup_logger

logger = setup_logger()

try:
    result = perform_operation()
except SpecificError as e:
    logger.error(f"Operation failed: {e}")
    raise HTTPException(status_code=400, detail="User-friendly message")
except Exception as e:
    logger.exception(f"Unexpected error: {e}")
    raise HTTPException(status_code=500, detail="Internal server error")
```

### Environment Variables

- All config via `os.environ.get()` in `onyx/configs/` modules
- Default values provided for local dev
- Never hardcode secrets
- Document new env vars in `.env.example` or equivalent

### Celery Tasks

```python
from onyx.background.celery.celery_app import celery_app

@celery_app.task(
    name="task_name",
    bind=True,
    max_retries=3,
    default_retry_delay=60,
)
def my_task(self, param: str) -> None:
    try:
        ...
    except Exception as e:
        self.retry(exc=e)
```

### Alembic Migrations

```bash
# Create new migration
cd backend
alembic revision --autogenerate -m "description of change"

# Apply migrations
alembic upgrade head

# Rollback one step
alembic downgrade -1
```

- Always review autogenerated migrations before committing
- Test both upgrade and downgrade paths
- Use descriptive migration messages

## TypeScript / React (Frontend)

### Style & Formatting

| Rule | Convention |
|------|-----------|
| Formatter | Prettier (auto via hook) |
| Linter | ESLint |
| Type checking | TypeScript strict mode |
| Naming (files) | kebab-case: `chat-message-list.tsx` |
| Naming (components) | PascalCase: `ChatMessageList` |
| Naming (hooks) | camelCase with `use` prefix: `useChatMessages` |
| Naming (utils) | camelCase: `formatDuration` |
| Naming (constants) | UPPER_SNAKE_CASE |

### Component Pattern

```tsx
// Functional component with TypeScript props
interface ChatMessageProps {
  message: Message;
  isLast: boolean;
  onEdit?: (id: string, content: string) => void;
}

export function ChatMessage({ message, isLast, onEdit }: ChatMessageProps) {
  // Hooks first
  const { user } = useUser();

  // Derived state
  const isOwner = user?.id === message.authorId;

  // Event handlers
  const handleEdit = (content: string) => {
    onEdit?.(message.id, content);
  };

  return (
    <div className="flex gap-2 p-4">
      {/* ... */}
    </div>
  );
}
```

### Data Fetching (SWR)

```tsx
import useSWR from "swr";
import { fetcher } from "@/lib/fetcher";

export function useChatSessions() {
  const { data, error, isLoading, mutate } = useSWR<ChatSession[]>(
    "/api/chat/sessions",
    fetcher
  );

  return { sessions: data, error, isLoading, refresh: mutate };
}
```

### State Management

| Scope | Approach |
|-------|----------|
| Server data | SWR hooks |
| Global app state | React Context or Zustand |
| Form state | Formik + Yup |
| Local UI state | useState / useReducer |

### API Calls

```tsx
// All API calls go through /api/* proxy to Python backend
const response = await fetch("/api/chat/send-message", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ message, chatSessionId }),
});

if (!response.ok) {
  throw new Error(`API error: ${response.status}`);
}
```

### Styling

```tsx
// Tailwind CSS classes (preferred)
<div className="flex items-center gap-2 rounded-lg bg-background p-4">

// CSS variables for theming
<div style={{ color: "var(--text-primary)" }}>

// Dark mode via next-themes
<div className="bg-white dark:bg-gray-900">
```

### Design System Usage Priority

1. `@onyx/opal` components (internal design system)
2. `shadcn/ui` primitives (Radix-based)
3. `refresh-components/` (modern replacements)
4. Legacy `components/` (avoid for new code)

### Error Handling (Frontend)

```tsx
try {
  const result = await apiCall();
  return result;
} catch (error) {
  console.error("Operation failed:", error);
  // Show user-friendly toast/notification
  toast.error("Something went wrong. Please try again.");
}
```

## Features Layer (Fork-Specific Code)

### Golden Rules -- Upstream Conflict Avoidance

| Rule | Details |
|------|---------|
| Only CREATE in `backend/features/` and `web/src/app/features/` | Upstream does not have these directories |
| Only IMPORT from upstream, never modify upstream code | Prevents merge conflicts on sync |
| NEVER modify `backend/onyx/`, `backend/ee/`, `web/src/app/` (outside `features/`) | These sync with upstream every 6h |

### Backend Features Pattern (`backend/features/`)

Entry point: `features.onyx.main:app` (wraps `onyx.main.get_application()`)

```python
# features/onyx/main.py pattern:
from onyx.main import get_application
from onyx.auth.users import current_user  # import, never modify

app = get_application()
app.include_router(my_router)
check_router_auth(app)  # MUST call after adding routers
```

**Router conventions:**
- All routers mount under `FEATURES_API_PREFIX` (default: `/api/features/`)
- Every endpoint MUST include `_: User | None = Depends(current_user)` for auth
- Config in `features/onyx/configs/app_configs.py`

### Frontend Features Pattern (`web/src/app/features/`)

- `layout.tsx` -- Auth-gated layout (redirects to `/auth/login` if unauthenticated)
- All custom pages go under this route
- Import shared components from `@/components/`, never duplicate

### Conflict Risk & Mitigation

| Risk | Likelihood | Mitigation |
|------|-----------|------------|
| Upstream renames `current_user` / `get_application` | Low | Run tests after every upstream sync |
| Upstream creates `features/` directory | Very Low | Rename to `custom/` or `tee/` |
| Upstream changes FastAPI middleware order | Low | Pin wrapper to `get_application()` output |

## Testing

### Backend Tests

```bash
# Run all tests
cd backend && pytest

# Run specific test
pytest tests/unit/test_feature.py -v

# With coverage
pytest --cov=onyx --cov-report=term-missing
```

- Use `pytest` for all Python tests
- Mock external services (LLM, Vespa, S3)
- Test both success and error paths
- Aim for 80%+ coverage on new code

### Frontend Tests

```bash
# Unit tests (Jest)
cd web && npm test

# E2E tests (Playwright)
cd web && npx playwright test
```

- Use Jest for unit/component tests
- Use Playwright for E2E tests
- Test critical user flows
- Mock API responses in unit tests

## Git Conventions

### Commit Messages

```
<type>: <description>

<optional body>
```

Types: `feat`, `fix`, `refactor`, `docs`, `test`, `chore`, `perf`, `ci`

### Branch Strategy

- `main` -- auto-syncs with upstream, always deployable
- `feature/<name>` -- feature branches from main
- `fix/<name>` -- bug fix branches
- `chore/<name>` -- maintenance branches

### Pre-Commit Checklist

- [ ] No hardcoded secrets
- [ ] Linting passes
- [ ] Tests pass
- [ ] No `console.log` in production code
- [ ] Types are correct (TypeScript strict, mypy)
- [ ] New env vars documented

## Security Checklist

- [ ] User input validated (Pydantic on backend, Zod/Yup on frontend)
- [ ] SQL injection prevention (SQLAlchemy parameterized queries)
- [ ] XSS prevention (React auto-escaping + sanitize HTML)
- [ ] Authentication/authorization on all endpoints
- [ ] Credentials encrypted at rest
- [ ] Rate limiting on public endpoints
- [ ] Error messages don't leak internals
