# Code Standards

## General Principles

- **YAGNI** -- Don't build it until you need it
- **KISS** -- Simplest solution that works
- **DRY** -- Extract shared logic, avoid copy-paste
- **Immutability** -- Create new objects, don't mutate

## File Organization

- Target file length: <200 lines where practical; hard cap: 800 lines
- Use kebab-case for filenames: `user-auth-handler.py`, `chat-message-list.tsx`
- Organize by feature/domain, not by type
- One concept per module, high cohesion, low coupling

## Python (Backend)

### Style & Formatting

| Rule | Convention |
|------|-----------|
| Formatter | Black (via pre-commit or manual) |
| Linter | Ruff |
| Type checking | mypy (partial) |
| Import order | stdlib > third-party > local (isort) |
| Naming | `snake_case` for functions/variables, `PascalCase` for classes |
| Constants | `UPPER_SNAKE_CASE` |
| Max line length | 88 (Black default) |

### Project Structure Conventions

```python
# FastAPI router pattern
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from onyx.db.engine import get_session

router = APIRouter(prefix="/api/endpoint", tags=["endpoint"])

@router.get("/items")
def list_items(
    db_session: Session = Depends(get_session),
    user: User | None = Depends(current_user),
) -> list[ItemResponse]:
    ...
```

### Pydantic Models

```python
from pydantic import BaseModel

class ItemCreate(BaseModel):
    name: str
    description: str | None = None

class ItemResponse(BaseModel):
    id: int
    name: str
    description: str | None

    class Config:
        from_attributes = True
```

### Database (SQLAlchemy)

```python
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from onyx.db.models import Base

class Item(Base):
    __tablename__ = "item"

    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    owner_id = Column(Integer, ForeignKey("user.id"))
    owner = relationship("User", back_populates="items")
```

### Error Handling

```python
from onyx.utils.logger import setup_logger

logger = setup_logger()

try:
    result = perform_operation()
except SpecificError as e:
    logger.error(f"Operation failed: {e}")
    raise HTTPException(status_code=400, detail="User-friendly message")
except Exception as e:
    logger.exception(f"Unexpected error: {e}")
    raise HTTPException(status_code=500, detail="Internal server error")
```

### Environment Variables

- All config via `os.environ.get()` in `onyx/configs/` modules
- Default values provided for local dev
- Never hardcode secrets
- Document new env vars in `.env.example` or equivalent

### Celery Tasks

```python
from onyx.background.celery.celery_app import celery_app

@celery_app.task(
    name="task_name",
    bind=True,
    max_retries=3,
    default_retry_delay=60,
)
def my_task(self, param: str) -> None:
    try:
        ...
    except Exception as e:
        self.retry(exc=e)
```

### Alembic Migrations

```bash
# Create new migration
cd backend
alembic revision --autogenerate -m "description of change"

# Apply migrations
alembic upgrade head

# Rollback one step
alembic downgrade -1
```

- Always review autogenerated migrations before committing
- Test both upgrade and downgrade paths
- Use descriptive migration messages

## TypeScript / React (Frontend)

### Style & Formatting

| Rule | Convention |
|------|-----------|
| Formatter | Prettier (auto via hook) |
| Linter | ESLint |
| Type checking | TypeScript strict mode |
| Naming (files) | kebab-case: `chat-message-list.tsx` |
| Naming (components) | PascalCase: `ChatMessageList` |
| Naming (hooks) | camelCase with `use` prefix: `useChatMessages` |
| Naming (utils) | camelCase: `formatDuration` |
| Naming (constants) | UPPER_SNAKE_CASE |

### Component Pattern

```tsx
// Functional component with TypeScript props
interface ChatMessageProps {
  message: Message;
  isLast: boolean;
  onEdit?: (id: string, content: string) => void;
}

export function ChatMessage({ message, isLast, onEdit }: ChatMessageProps) {
  // Hooks first
  const { user } = useUser();

  // Derived state
  const isOwner = user?.id === message.authorId;

  // Event handlers
  const handleEdit = (content: string) => {
    onEdit?.(message.id, content);
  };

  return (
    <div className="flex gap-2 p-4">
      {/* ... */}
    </div>
  );
}
```

### Data Fetching (SWR)

```tsx
import useSWR from "swr";
import { fetcher } from "@/lib/fetcher";

export function useChatSessions() {
  const { data, error, isLoading, mutate } = useSWR<ChatSession[]>(
    "/api/chat/sessions",
    fetcher
  );

  return { sessions: data, error, isLoading, refresh: mutate };
}
```

### State Management

| Scope | Approach |
|-------|----------|
| Server data | SWR hooks |
| Global app state | React Context or Zustand |
| Form state | Formik + Yup |
| Local UI state | useState / useReducer |

### API Calls

```tsx
// All API calls go through /api/* proxy to Python backend
const response = await fetch("/api/chat/send-message", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ message, chatSessionId }),
});

if (!response.ok) {
  throw new Error(`API error: ${response.status}`);
}
```

### Styling

```tsx
// Tailwind CSS classes (preferred)
<div className="flex items-center gap-2 rounded-lg bg-background p-4">

// CSS variables for theming
<div style={{ color: "var(--text-primary)" }}>

// Dark mode via next-themes
<div className="bg-white dark:bg-gray-900">
```

### Design System Usage Priority

1. `@onyx/opal` components (internal design system)
2. `shadcn/ui` primitives (Radix-based)
3. `refresh-components/` (modern replacements)
4. Legacy `components/` (avoid for new code)

### Error Handling (Frontend)

```tsx
try {
  const result = await apiCall();
  return result;
} catch (error) {
  console.error("Operation failed:", error);
  // Show user-friendly toast/notification
  toast.error("Something went wrong. Please try again.");
}
```

## Testing

### Backend Tests

```bash
# Run all unit tests
cd backend && py.test -o junit_family=xunit2 -xv --ff tests/unit

# Run specific test
pytest tests/unit/test_feature.py -v

# With coverage (local optional)
pytest --cov=onyx --cov-report=term-missing

# Type check (aligned with CI)
mypy .
```

- Use `pytest` for all Python tests
- Mock external services (LLM, Vespa, S3)
- Test both success and error paths
- Aim for 80%+ coverage on new code

### Frontend Tests

```bash
# Unit tests (Jest)
cd web && npm test

# Lint
npm run lint

# Type check
npm run types:check

# E2E tests (Playwright)
npx playwright test
```

- Use Jest for unit/component tests
- Use Playwright for E2E tests
- Test critical user flows
- Mock API responses in unit tests

## Git Conventions

### Commit Messages

```
<type>: <description>

<optional body>
```

Types: `feat`, `fix`, `refactor`, `docs`, `test`, `chore`, `perf`, `ci`

### Branch Strategy

- `main` -- sync target for upstream updates; keep deployable
- Upstream sync is currently triggered via manual dispatch workflow (`.github/workflows/sync-upstream.yml`)
- `feature/<name>` -- feature branches from main
- `fix/<name>` -- bug fix branches
- `chore/<name>` -- maintenance branches

### Pre-Commit Checklist

- [ ] No hardcoded secrets
- [ ] Linting passes
- [ ] Tests pass
- [ ] No `console.log` in production code
- [ ] Types are correct (TypeScript strict, mypy)
- [ ] New env vars documented

## Security Checklist

- [ ] User input validated (Pydantic on backend, Zod/Yup on frontend)
- [ ] SQL injection prevention (SQLAlchemy parameterized queries)
- [ ] XSS prevention (React auto-escaping + sanitize HTML)
- [ ] Authentication/authorization on all endpoints
- [ ] Credentials encrypted at rest
- [ ] Rate limiting on public endpoints
- [ ] Error messages don't leak internals
